可以划分为以下三种情况：

1. 大多数应用会直接信任系统的根证书列表，所以如果有权限的话把根证书安装到操作系统证书存储中就行；
2. 某些应用或环境则使用特定的根证书存储，需要安装到对应的位置。
3. 直接在应用中指定要信任的证书。这通常是在专门的配置文件、命令行参数或直接在源代码中

## 根证书存储的位置

在客户端安装自签名根证书到对应的根证书存储，则相应的客户端应用会信任由该自签名根证书颁发的 SSL 证书。常见系统和应用如下：

- Windows

Windows 根证书存储分“本地计算机”（系统）和“当前用户”，通常存储在注册表中。

- Linux

Linux 主要发行版系统根证书存储位置速查表：

| 操作系统               | 路径                                                         |
| :--------------------- | :----------------------------------------------------------- |
| Debian/Ubuntu/Gentoo   | /etc/ssl/certs/ca-certificates.crt                           |
| Fedora/CentOS/RHEL 7.x | /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem            |
| Fedora/CentOS/RHEL 6.x | /etc/pki/tls/certs/ca-bundle.crt                             |
| Alpine Linux <=3.11    | /etc/ssl/cert.pem                                            |
| Alpine Linux >=3.12    | /etc/ssl/certs/ca-certificates.crt (/etc/ssl/cert.pem 是符号链接) |
| OpenSUSE/SLES          | /var/lib/ca-certificates/ca-bundle.pem /etc/ssl/ca-bundle.pem |

- MacOS

MacOS 在 Keychains 中

- Java

Java 环境有特定的可信根证书存储，不同版本也存在一些区别。但都通过 keytool 来管理。

- NodeJS

NodeJS 官方建议使用环境变量 `NODE_EXTRA_CA_CERTS` 来指定额外的根证书。

- Firefox

Firefox 浏览器有自己的可信根证书列表

## 系统根证书

Edge\Chrome 浏览器等很多应用自动信任操作系统的证书列表（需要注意 Chrome 维护着额外的证书黑名单）。

### MacOS

```bash
# 安装 root_ca.crt
sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ~/root_ca.crt

# 使用以下命令来验证 CA 证书是否已安装
sudo security find-certificate -c "Your CA Certificate Name"/Library/Keychains/System.keychain

# 删除指定的证书
sudo security delete-certificate -c "<name of existing certificate>"

```

### Linux

不同发行版，更新根证书存储的命令不一样，用来保存私有证书的路径也不一样

先复制自签名 CA 证书到特定路径，再运行命令更新根证书存储

#### Debian/Ubuntu/Gentoo

```bash
# Debian/Ubuntu/Gentoo
# - 安装
sudo cp root_ca.crt /usr/local/share/ca-certificates/root_ca.crt
# update-ca-certificates 会添加 /etc/ca-certificates.conf 配置文件中指定的证书
#   另外所有 /usr/local/share/ca-certificates/*.crt 会被列为隐式信任
sudo update-ca-certificates

# - 删除
sudo rm /usr/local/share/ca-certificates/root_ca.crt
sudo update-ca-certificates --fresh
```

#### CentOS/Fedora/RHEL

```bash
# CentOS/Fedora/RHEL
dnf install ca-certificates
# 启用动态 CA 配置功能：
update-ca-trust force-enable
cp root_ca.crt /etc/pki/ca-trust/source/anchors/
update-ca-trust
```

#### Alpine

```bash
# Alpine
apk update && apk add --no-cache ca-certificates
cp root_ca.crt /usr/local/share/ca-certificates/
update-ca-certificates
```

#### OpenSUSE/SLES

```bash
# OpenSUSE/SLES
cp root_ca.crt /etc/pki/trust/anchors/
update-ca-certificates

```

### Windows

(1) 打开证书管理控制台：

- 按 `Win + R` 打开运行对话框，输入 `mmc` 并按回车键。
- 在“文件”菜单中，选择“添加/删除管理单元…”。

(2) 添加证书管理单元：
- 在“添加/删除管理单元”对话框中，从左侧列表中选择“证书”，然后点击“添加”按钮。
- 选择“计算机账户”，然后点击“下一步”。
- 选择“本地计算机”，然后点击“完成”。

(3) 导入 CA 证书：

- 在“控制台根”节点下，展开“证书 (本地计算机)”。
- 展开“受信任的根证书颁发机构”节点，然后右键点击“证书”，选择“所有任务” -> “导入…”。

(4) 导入向导：

- 在证书导入向导中，点击“下一步”。
- 点击“浏览”并找到复制到 Windows 机器上的 `ca-cert.pem` 文件，然后点击“下一步”。
- 选择“将所有的证书放入下列存储”并确认选择的是“受信任的根证书颁发机构”，然后点击“下一步”。
- 点击“完成”完成证书的导入。

(5) 确认安装：

- 导入成功后，应该会看到一个消息框提示“导入成功”。

<img src="./.assets/信任自签证书/win_cert_import.png" alt="Windows 导入根证书" style="zoom:50%;" />

winserver 安装 powershell 命令:

```powershell
certutil -addstore -f Root ca.pem 
```

win 11 安装 ca证书(需要administrator)

```powershell
# 安装ca证书
 Import-Certificate -FilePath .\ca-cert.pem -CertStoreLocation Cert:\LocalMachine\Root

# 检查安装是否成功
 Get-ChildItem -Path Cert:\LocalMachine\Root | Where-Object { $_.Subject -match "alpha-quant.tech" }

```

## 其他应用或环境

### NodeJS

Nodejs 使用自签证书 `export NODE_OPTIONS=--use-openssl-ca`，即可使用操作系统 CA

也可以使用 `export NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-cert-root_ca.pem`

命令中的 ca-cert-root_ca.pem 是由安装 root_ca.crt 时由`update-ca-certificates` 生成，Node 环境变量只需要指定附加的证书。请修改为你自己的文件名。两种环境变量无效的情况，一是 node 作为 `setuid root` 运行或拥有 Linux 文件 capabilities；二是仅启动时读取，运行时用 process.env 修改没有影响。

### Java

Java 的 keystore 通常存储在 `$JAVA_HOME/lib/security/cacerts` 中。keytool 命令行不指定 `-keystore` 参数时，有可能存储于 `~/.keystore` 中。

使用 keytool 命令行导入自签名 CA 证书（Oracle JDK 或 OpenJDK 的 keytool 参数可能有点差别，具体参数可以查看帮助）：

```
keytool -importcert -file root_ca.crt -alias root_ca -keystore cacerts -storepass changeit -noprompt
```

例如

```bash
keytool -importcert \
    -alias alpha-quant \
    -keystore /opt/java/openjdk/lib/security/cacerts \
    -file /usr/local/share/ca-certificates/alpha-quant.tech.CA.crt \
    -storepass changeit -noprompt
```

### Python Requests

Requests 使用 certifi 包提供的 CA 证书 bundle 作为默认信任源。这个证书 bundle 包含了全球主流 CA 的根证书，确保大多数 HTTPS 连接能够顺利验证

```python
from certifi import where
 

# 返回默认 CA 证书 bundle 路径
def where():
    return certifi.where()
```

可以通过以下代码获取当前环境中 Requests 使用的默认 CA 证书路径：

```python
import requests
from requests.utils import DEFAULT_CA_BUNDLE_PATH
 

print(DEFAULT_CA_BUNDLE_PATH)
```

临时解决方案：禁用证书验证（不推荐）

```python
import requests

# 禁用证书验证（生产环境中禁止使用）
response = requests.get("https://self-signed.badssl.com/", verify=False)

# 禁用 urllib3 的警告
import urllib3


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
```

可以在单个请求中通过 verify 参数指定 CA 证书文件路径：

```python
import requests


# 使用自定义 CA 证书验证
response = requests.get(
    "https://internal-server.example.com",
    verify="/path/to/custom-ca.pem"
)
```

对于需要多次请求同一服务器的场景，使用 Session 对象配置 CA 证书

```python
import requests


session = requests.Session()
# 为会话设置自定义 CA 证书
session.verify = "/path/to/custom-ca.pem"

# 后续所有请求将使用此 CA 配置
response1 = session.get("https://internal-server.example.com/api/data")
response2 = session.get("https://internal-server.example.com/api/status")
```

对于需要全局信任自定义 CA 的场景，可以通过设置环境变量 REQUESTS_CA_BUNDLE 或 CURL_CA_BUNDLE 来指定 CA 证书路径：

```bash
# Linux/macOS
export REQUESTS_CA_BUNDLE="/path/to/custom-ca.pem"
 
# Windows (PowerShell)
$env:REQUESTS_CA_BUNDLE = "C:\path\to\custom-ca.pem"
```

建议安装自签证书到操作系统，然后指向 `/etc/ssl/certs/ca-certificates.crt`

### Firefox

“选项”->隐私与安全->证书->查看证书->证书颁发机构->导入

### wget

wget 默认使用 `/etc/ssl/cert.pem` 作为根证书存储文件。如果该文件不存在，或者与更新的根证书存储内容不同步，可以手动创建符号链接。

例如 Alpine 3.11及更低版本，在安装新证书后需要：

```bash
rm /etc/ssl/cert.pem
ln -s /etc/ssl/certs/ca-certificates.crt /etc/ssl/cert.pem
```

## Docker 容器

把主机系统里的根证书存储文件挂载到容器系统里的对应位置

例如以主机系统为 CentOS 7，容器镜像系统为 alpine，只读挂载：

```bash
docker run --rm -it \
  --volume /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem:/etc/ssl/certs/ca-certificates.crt:ro \
  alpine:3.12  -d
```

