## å†…å­˜åˆ†é…å™¨

ç¨‹åºä¸­çš„æ•°æ®å’Œå˜é‡éƒ½ä¼šè¢«åˆ†é…åˆ°ç¨‹åºæ‰€åœ¨çš„è™šæ‹Ÿå†…å­˜ä¸­ï¼Œå†…å­˜ç©ºé—´åŒ…å«ä¸¤ä¸ªé‡è¦åŒºåŸŸï¼šæ ˆåŒºï¼ˆStackï¼‰å’Œå †åŒºï¼ˆHeapï¼‰

- å‡½æ•°è°ƒç”¨çš„å‚æ•°ã€è¿”å›å€¼ä»¥åŠå±€éƒ¨å˜é‡å¤§éƒ½ä¼šè¢«åˆ†é…åˆ°æ ˆä¸Šï¼Œè¿™éƒ¨åˆ†å†…å­˜ä¼šç”±ç¼–è¯‘å™¨è¿›è¡Œç®¡ç†

- ä¸åŒç¼–ç¨‹è¯­è¨€ä½¿ç”¨ä¸åŒçš„æ–¹æ³•ç®¡ç†å †åŒºçš„å†…å­˜ï¼ŒC++ ç­‰ç¼–ç¨‹è¯­è¨€ä¼šç”±å·¥ç¨‹å¸ˆä¸»åŠ¨ç”³è¯·å’Œé‡Šæ”¾å†…å­˜ï¼ŒGo ä»¥åŠ Java ç­‰ç¼–ç¨‹è¯­è¨€ä¼šç”±å·¥ç¨‹å¸ˆå’Œç¼–è¯‘å™¨å…±åŒç®¡ç†ï¼Œå †ä¸­çš„å¯¹è±¡ç”±å†…å­˜åˆ†é…å™¨åˆ†é…å¹¶ç”±åƒåœ¾æ”¶é›†å™¨å›æ”¶

## å†…å­˜ç®¡ç†ç»„ä»¶

å†…å­˜ç®¡ç†ä¸€èˆ¬åŒ…å«ä¸‰ä¸ªä¸åŒçš„ç»„ä»¶ï¼Œåˆ†åˆ«æ˜¯ç”¨æˆ·ç¨‹åºï¼ˆMutatorï¼‰ã€åˆ†é…å™¨ï¼ˆAllocatorï¼‰å’Œæ”¶é›†å™¨ï¼ˆCollectorï¼‰ï¼Œå½“ç”¨æˆ·ç¨‹åºç”³è¯·å†…å­˜æ—¶ï¼Œå®ƒä¼šé€šè¿‡å†…å­˜åˆ†é…å™¨ç”³è¯·æ–°å†…å­˜ï¼Œè€Œåˆ†é…å™¨ä¼šè´Ÿè´£ä»å †ä¸­åˆå§‹åŒ–ç›¸åº”çš„å†…å­˜åŒºåŸŸ

![image-20231121224806568](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121224806568.png)

## åˆ†é…æ–¹æ³•

ç¼–ç¨‹è¯­è¨€çš„å†…å­˜åˆ†é…å™¨ä¸€èˆ¬åŒ…å«ä¸¤ç§åˆ†é…æ–¹æ³•

- çº¿æ€§åˆ†é…å™¨ï¼ˆSequential Allocatorï¼ŒBump Allocatorï¼‰
- ç©ºé—²é“¾è¡¨åˆ†é…å™¨ï¼ˆFree-List Allocatorï¼‰

### çº¿æ€§åˆ†é…å™¨

çº¿æ€§åˆ†é…ï¼ˆBump Allocatorï¼‰æ˜¯ä¸€ç§é«˜æ•ˆçš„å†…å­˜åˆ†é…æ–¹æ³•ï¼Œä½†æ˜¯æœ‰è¾ƒå¤§çš„å±€é™æ€§ã€‚å½“ä½¿ç”¨çº¿æ€§åˆ†é…å™¨æ—¶ï¼Œåªéœ€è¦åœ¨å†…å­˜ä¸­ç»´æŠ¤ä¸€ä¸ªæŒ‡å‘å†…å­˜ç‰¹å®šä½ç½®çš„æŒ‡é’ˆï¼Œå¦‚æœç”¨æˆ·ç¨‹åºå‘åˆ†é…å™¨ç”³è¯·å†…å­˜ï¼Œåˆ†é…å™¨åªéœ€è¦æ£€æŸ¥å‰©ä½™çš„ç©ºé—²å†…å­˜ã€è¿”å›åˆ†é…çš„å†…å­˜åŒºåŸŸå¹¶ä¿®æ”¹æŒ‡é’ˆåœ¨å†…å­˜ä¸­çš„ä½ç½®ï¼Œå³ç§»åŠ¨ä¸‹å›¾ä¸­çš„æŒ‡é’ˆï¼š

![image-20231121225020587](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225020587.png)

è™½ç„¶çº¿æ€§åˆ†é…å™¨å®ç°ä¸ºå®ƒå¸¦æ¥äº†è¾ƒå¿«çš„æ‰§è¡Œé€Ÿåº¦ä»¥åŠè¾ƒä½çš„å®ç°å¤æ‚åº¦ï¼Œä½†æ˜¯çº¿æ€§åˆ†é…å™¨æ— æ³•åœ¨å†…å­˜è¢«é‡Šæ”¾æ—¶é‡ç”¨å†…å­˜ã€‚å¦‚æœå·²ç»åˆ†é…çš„å†…å­˜è¢«å›æ”¶ï¼Œçº¿æ€§åˆ†é…å™¨æ— æ³•é‡æ–°åˆ©ç”¨çº¢è‰²çš„å†…å­˜ï¼š

![image-20231121225048848](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225048848.png)

å› ä¸ºçº¿æ€§åˆ†é…å™¨å…·æœ‰ä¸Šè¿°ç‰¹æ€§ï¼Œæ‰€ä»¥éœ€è¦ä¸åˆé€‚çš„åƒåœ¾å›æ”¶ç®—æ³•é…åˆä½¿ç”¨ï¼Œä¾‹å¦‚ï¼šæ ‡è®°å‹ç¼©ï¼ˆMark-Compactï¼‰ã€å¤åˆ¶å›æ”¶ï¼ˆCopying GCï¼‰å’Œåˆ†ä»£å›æ”¶ï¼ˆGenerational GCï¼‰ç­‰ç®—æ³•ï¼Œå®ƒä»¬å¯ä»¥é€šè¿‡æ‹·è´çš„æ–¹å¼æ•´ç†å­˜æ´»å¯¹è±¡çš„ç¢ç‰‡ï¼Œå°†ç©ºé—²å†…å­˜å®šæœŸåˆå¹¶ï¼Œè¿™æ ·å°±èƒ½åˆ©ç”¨çº¿æ€§åˆ†é…å™¨çš„æ•ˆç‡æå‡å†…å­˜åˆ†é…å™¨çš„æ€§èƒ½

### ç©ºé—²é“¾è¡¨åˆ†é…å™¨

ç©ºé—²é“¾è¡¨åˆ†é…å™¨ï¼ˆFree-List Allocatorï¼‰å¯ä»¥é‡ç”¨å·²ç»è¢«é‡Šæ”¾çš„å†…å­˜ï¼Œå®ƒåœ¨å†…éƒ¨ä¼šç»´æŠ¤ä¸€ä¸ªç±»ä¼¼é“¾è¡¨çš„æ•°æ®ç»“æ„ã€‚å½“ç”¨æˆ·ç¨‹åºç”³è¯·å†…å­˜æ—¶ï¼Œç©ºé—²é“¾è¡¨åˆ†é…å™¨ä¼šä¾æ¬¡éå†ç©ºé—²çš„å†…å­˜å—ï¼Œæ‰¾åˆ°è¶³å¤Ÿå¤§çš„å†…å­˜ï¼Œç„¶åç”³è¯·æ–°çš„èµ„æºå¹¶ä¿®æ”¹é“¾è¡¨ï¼š

![image-20231121225210268](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225210268.png)

å› ä¸ºä¸åŒçš„å†…å­˜å—é€šè¿‡æŒ‡é’ˆæ„æˆäº†é“¾è¡¨ï¼Œæ‰€ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼çš„åˆ†é…å™¨å¯ä»¥é‡æ–°åˆ©ç”¨å›æ”¶çš„èµ„æºï¼Œä½†æ˜¯å› ä¸ºåˆ†é…å†…å­˜æ—¶éœ€è¦éå†é“¾è¡¨ï¼Œæ‰€ä»¥å®ƒçš„æ—¶é—´å¤æ‚åº¦æ˜¯ ğ‘‚(ğ‘›)ã€‚ç©ºé—²é“¾è¡¨åˆ†é…å™¨å¯ä»¥é€‰æ‹©ä¸åŒçš„ç­–ç•¥åœ¨é“¾è¡¨ä¸­çš„å†…å­˜å—ä¸­è¿›è¡Œé€‰æ‹©ï¼Œæœ€å¸¸è§çš„æ˜¯ä»¥ä¸‹å››ç§ï¼š

- é¦–æ¬¡é€‚åº”ï¼ˆFirst-Fitï¼‰â€” ä»é“¾è¡¨å¤´å¼€å§‹éå†ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¤§å°å¤§äºç”³è¯·å†…å­˜çš„å†…å­˜å—ï¼›
- å¾ªç¯é¦–æ¬¡é€‚åº”ï¼ˆNext-Fitï¼‰â€” ä»ä¸Šæ¬¡éå†çš„ç»“æŸä½ç½®å¼€å§‹éå†ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¤§å°å¤§äºç”³è¯·å†…å­˜çš„å†…å­˜å—ï¼›
- æœ€ä¼˜é€‚åº”ï¼ˆBest-Fitï¼‰â€” ä»é“¾è¡¨å¤´éå†æ•´ä¸ªé“¾è¡¨ï¼Œé€‰æ‹©æœ€åˆé€‚çš„å†…å­˜å—ï¼›
- éš”ç¦»é€‚åº”ï¼ˆSegregated-Fitï¼‰â€” å°†å†…å­˜åˆ†å‰²æˆå¤šä¸ªé“¾è¡¨ï¼Œæ¯ä¸ªé“¾è¡¨ä¸­çš„å†…å­˜å—å¤§å°ç›¸åŒï¼Œç”³è¯·å†…å­˜æ—¶å…ˆæ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„é“¾è¡¨ï¼Œå†ä»é“¾è¡¨ä¸­é€‰æ‹©åˆé€‚çš„å†…å­˜å—ï¼›

Go è¯­è¨€ä½¿ç”¨çš„å†…å­˜åˆ†é…ç­–ç•¥ä¸éš”ç¦»é€‚åº”ç­–ç•¥æœ‰äº›ç›¸ä¼¼

éš”ç¦»é€‚åº”ç­–ç•¥ä¼šå°†å†…å­˜åˆ†å‰²æˆç”± 4ã€8ã€16ã€32 å­—èŠ‚çš„å†…å­˜å—ç»„æˆçš„é“¾è¡¨ï¼Œå½“å‘å†…å­˜åˆ†é…å™¨ç”³è¯· 8 å­—èŠ‚çš„å†…å­˜æ—¶ï¼Œå®ƒä¼šåœ¨ä¸Šå›¾ä¸­æ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„ç©ºé—²å†…å­˜å—å¹¶è¿”å›ã€‚éš”ç¦»é€‚åº”çš„åˆ†é…ç­–ç•¥å‡å°‘äº†éœ€è¦éå†çš„å†…å­˜å—æ•°é‡ï¼Œæé«˜äº†å†…å­˜åˆ†é…çš„æ•ˆç‡

![image-20231121225328596](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225328596.png)

## åˆ†çº§åˆ†é…

çº¿ç¨‹ç¼“å­˜åˆ†é…ï¼ˆThread-Caching Mallocï¼ŒTCMallocï¼‰æ˜¯ç”¨äºåˆ†é…å†…å­˜çš„æœºåˆ¶ï¼Œå®ƒæ¯” glibc ä¸­çš„ `malloc` è¿˜è¦å¿«å¾ˆå¤š

Go è¯­è¨€çš„å†…å­˜åˆ†é…å™¨å°±å€Ÿé‰´äº† TCMalloc çš„è®¾è®¡å®ç°é«˜é€Ÿçš„å†…å­˜åˆ†é…ï¼Œå®ƒçš„æ ¸å¿ƒç†å¿µæ˜¯ä½¿ç”¨å¤šçº§ç¼“å­˜å°†å¯¹è±¡æ ¹æ®å¤§å°åˆ†ç±»ï¼Œå¹¶æŒ‰ç…§ç±»åˆ«å®æ–½ä¸åŒçš„åˆ†é…ç­–ç•¥

### å¯¹è±¡å¤§å°

å› ä¸ºç¨‹åºä¸­çš„ç»å¤§å¤šæ•°å¯¹è±¡çš„å¤§å°éƒ½åœ¨ 32KB ä»¥ä¸‹ï¼Œè€Œç”³è¯·çš„å†…å­˜å¤§å°å½±å“ Go è¯­è¨€è¿è¡Œæ—¶åˆ†é…å†…å­˜çš„è¿‡ç¨‹å’Œå¼€é”€ï¼Œæ‰€ä»¥åˆ†åˆ«å¤„ç†å¤§å¯¹è±¡å’Œå°å¯¹è±¡æœ‰åˆ©äºæé«˜å†…å­˜åˆ†é…å™¨çš„æ€§èƒ½

|  ç±»åˆ«  |     å¤§å°      |
| :----: | :-----------: |
| å¾®å¯¹è±¡ |  `(0, 16B)`   |
| å°å¯¹è±¡ | `[16B, 32KB]` |
| å¤§å¯¹è±¡ | `(32KB, +âˆ)`  |

### å¤šçº§ç¼“å­˜

å†…å­˜åˆ†é…å™¨ä¸ä»…ä¼šåŒºåˆ«å¯¹å¾…å¤§å°ä¸åŒçš„å¯¹è±¡ï¼Œè¿˜ä¼šå°†å†…å­˜åˆ†æˆä¸åŒçš„çº§åˆ«åˆ†åˆ«ç®¡ç†ï¼ŒTCMalloc å’Œ Go è¿è¡Œæ—¶åˆ†é…å™¨éƒ½ä¼šå¼•å…¥çº¿ç¨‹ç¼“å­˜ï¼ˆThread Cacheï¼‰ã€ä¸­å¿ƒç¼“å­˜ï¼ˆCentral Cacheï¼‰å’Œé¡µå †ï¼ˆPage Heapï¼‰ä¸‰ä¸ªç»„ä»¶åˆ†çº§ç®¡ç†å†…å­˜ï¼š

![image-20231121225629643](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225629643.png)

- çº¿ç¨‹ç¼“å­˜ï¼šçº¿ç¨‹ç¼“å­˜å±äºæ¯ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ï¼Œå®ƒèƒ½å¤Ÿæ»¡è¶³çº¿ç¨‹ä¸Šç»å¤§å¤šæ•°çš„å†…å­˜åˆ†é…éœ€æ±‚ï¼Œå› ä¸ºä¸æ¶‰åŠå¤šçº¿ç¨‹ï¼Œæ‰€ä»¥ä¹Ÿä¸éœ€è¦ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤å†…å­˜ï¼Œè¿™èƒ½å¤Ÿå‡å°‘é”ç«äº‰å¸¦æ¥çš„æ€§èƒ½æŸè€—

- ä¸­å¿ƒç¼“å­˜ï¼šå½“çº¿ç¨‹ç¼“å­˜ä¸èƒ½æ»¡è¶³éœ€æ±‚æ—¶ï¼Œè¿è¡Œæ—¶ä¼šä½¿ç”¨ä¸­å¿ƒç¼“å­˜ä½œä¸ºè¡¥å……è§£å†³å°å¯¹è±¡çš„å†…å­˜åˆ†é…
- é¡µå †ï¼šåœ¨é‡åˆ° 32KB ä»¥ä¸Šçš„å¯¹è±¡æ—¶ï¼Œå†…å­˜åˆ†é…å™¨ä¼šé€‰æ‹©é¡µå †ç›´æ¥åˆ†é…å¤§å†…å­˜

è¿™ç§å¤šå±‚çº§çš„å†…å­˜åˆ†é…è®¾è®¡ä¸è®¡ç®—æœºæ“ä½œç³»ç»Ÿä¸­çš„å¤šçº§ç¼“å­˜æœ‰äº›ç±»ä¼¼ï¼Œå› ä¸ºå¤šæ•°çš„å¯¹è±¡éƒ½æ˜¯å°å¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡çº¿ç¨‹ç¼“å­˜å’Œä¸­å¿ƒç¼“å­˜æä¾›è¶³å¤Ÿçš„å†…å­˜ç©ºé—´ï¼Œå‘ç°èµ„æºä¸è¶³æ—¶ä»ä¸Šä¸€çº§ç»„ä»¶ä¸­è·å–æ›´å¤šçš„å†…å­˜èµ„æº

## è™šæ‹Ÿå†…å­˜å¸ƒå±€

åœ¨ Go è¯­è¨€ 1.10 ä»¥å‰çš„ç‰ˆæœ¬ï¼Œå †åŒºçš„å†…å­˜ç©ºé—´éƒ½æ˜¯è¿ç»­çš„ï¼›ä½†æ˜¯åœ¨ 1.11 ç‰ˆæœ¬ï¼ŒGo å›¢é˜Ÿä½¿ç”¨ç¨€ç–çš„å †å†…å­˜ç©ºé—´æ›¿ä»£äº†è¿ç»­çš„å†…å­˜ï¼Œè§£å†³äº†è¿ç»­å†…å­˜å¸¦æ¥çš„é™åˆ¶ä»¥åŠåœ¨ç‰¹æ®Šåœºæ™¯ä¸‹å¯èƒ½å‡ºç°çš„é—®é¢˜

### çº¿æ€§å†…å­˜

Go è¯­è¨€ç¨‹åºçš„ 1.10 ç‰ˆæœ¬åœ¨å¯åŠ¨æ—¶ä¼šåˆå§‹åŒ–æ•´ç‰‡è™šæ‹Ÿå†…å­˜åŒºåŸŸï¼Œå¦‚ä¸‹æ‰€ç¤ºçš„ä¸‰ä¸ªåŒºåŸŸ `spans`ã€`bitmap` å’Œ `arena` åˆ†åˆ«é¢„ç•™äº† 512MBã€16GB ä»¥åŠ 512GB çš„å†…å­˜ç©ºé—´ï¼Œè¿™äº›å†…å­˜å¹¶ä¸æ˜¯çœŸæ­£å­˜åœ¨çš„ç‰©ç†å†…å­˜ï¼Œè€Œæ˜¯è™šæ‹Ÿå†…å­˜ï¼š

![image-20231121225913200](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121225913200.png)

- `spans` åŒºåŸŸå­˜å‚¨äº†æŒ‡å‘å†…å­˜ç®¡ç†å•å…ƒ `runtime.mspan` çš„æŒ‡é’ˆï¼Œæ¯ä¸ªå†…å­˜å•å…ƒä¼šç®¡ç†å‡ é¡µçš„å†…å­˜ç©ºé—´ï¼Œæ¯é¡µå¤§å°ä¸º 8KBï¼›
- `bitmap` ç”¨äºæ ‡è¯† `arena` åŒºåŸŸä¸­çš„é‚£äº›åœ°å€ä¿å­˜äº†å¯¹è±¡ï¼Œä½å›¾ä¸­çš„æ¯ä¸ªå­—èŠ‚éƒ½ä¼šè¡¨ç¤ºå †åŒºä¸­çš„ 32 å­—èŠ‚æ˜¯å¦ç©ºé—²ï¼›
- `arena` åŒºåŸŸæ˜¯çœŸæ­£çš„å †åŒºï¼Œè¿è¡Œæ—¶ä¼šå°† 8KB çœ‹åšä¸€é¡µï¼Œè¿™äº›å†…å­˜é¡µä¸­å­˜å‚¨äº†æ‰€æœ‰åœ¨å †ä¸Šåˆå§‹åŒ–çš„å¯¹è±¡ï¼›

å¯¹äºä»»æ„ä¸€ä¸ªåœ°å€ï¼Œéƒ½å¯ä»¥æ ¹æ® `arena` çš„åŸºåœ°å€è®¡ç®—è¯¥åœ°å€æ‰€åœ¨çš„é¡µæ•°å¹¶é€šè¿‡ `spans` æ•°ç»„è·å¾—ç®¡ç†è¯¥ç‰‡å†…å­˜çš„ç®¡ç†å•å…ƒ `runtime.mspan`ï¼Œ`spans` æ•°ç»„ä¸­å¤šä¸ªè¿ç»­çš„ä½ç½®å¯èƒ½å¯¹åº”åŒä¸€ä¸ª `runtime.mspan` ç»“æ„

Go è¯­è¨€åœ¨åƒåœ¾å›æ”¶æ—¶ä¼šæ ¹æ®æŒ‡é’ˆçš„åœ°å€åˆ¤æ–­å¯¹è±¡æ˜¯å¦åœ¨å †ä¸­ï¼Œå¹¶é€šè¿‡ä¸Šä¸€æ®µä¸­ä»‹ç»çš„è¿‡ç¨‹æ‰¾åˆ°ç®¡ç†è¯¥å¯¹è±¡çš„ `runtime.mspan`ã€‚è¿™äº›éƒ½å»ºç«‹åœ¨ `å †åŒºçš„å†…å­˜æ˜¯è¿ç»­çš„` è¿™ä¸€å‡è®¾ä¸Šã€‚è¿™ç§è®¾è®¡è™½ç„¶ç®€å•å¹¶ä¸”æ–¹ä¾¿ï¼Œä½†æ˜¯åœ¨ C å’Œ Go æ··åˆä½¿ç”¨æ—¶ä¼šå¯¼è‡´ç¨‹åºå´©æºƒï¼š

1. åˆ†é…çš„å†…å­˜åœ°å€ä¼šå‘ç”Ÿå†²çªï¼Œå¯¼è‡´å †çš„åˆå§‹åŒ–å’Œæ‰©å®¹å¤±è´¥ï¼›
2. æ²¡æœ‰è¢«é¢„ç•™çš„å¤§å—å†…å­˜å¯èƒ½ä¼šè¢«åˆ†é…ç»™ C è¯­è¨€çš„äºŒè¿›åˆ¶ï¼Œå¯¼è‡´æ‰©å®¹åçš„å †ä¸è¿ç»­ï¼›

çº¿æ€§çš„å †å†…å­˜éœ€è¦é¢„ç•™å¤§å—çš„å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯ç”³è¯·å¤§å—çš„å†…å­˜ç©ºé—´è€Œä¸ä½¿ç”¨æ˜¯ä¸åˆ‡å®é™…çš„ï¼Œä¸é¢„ç•™å†…å­˜ç©ºé—´å´ä¼šåœ¨ç‰¹æ®Šåœºæ™¯ä¸‹é€ æˆç¨‹åºå´©æºƒã€‚è™½ç„¶è¿ç»­å†…å­˜çš„å®ç°æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯è¿™äº›é—®é¢˜ä¹Ÿæ²¡æœ‰åŠæ³•å¿½ç•¥

### ç¨€ç–å†…å­˜

ç¨€ç–å†…å­˜æ˜¯ Go è¯­è¨€åœ¨ 1.11 ä¸­æå‡ºçš„æ–¹æ¡ˆï¼Œä½¿ç”¨ç¨€ç–çš„å†…å­˜å¸ƒå±€ä¸ä»…èƒ½ç§»é™¤å †å¤§å°çš„ä¸Šé™ï¼Œè¿˜èƒ½è§£å†³ C å’Œ Go æ··åˆä½¿ç”¨æ—¶çš„åœ°å€ç©ºé—´å†²çªé—®é¢˜ã€‚ä¸è¿‡å› ä¸ºåŸºäºç¨€ç–å†…å­˜çš„å†…å­˜ç®¡ç†å¤±å»äº†å†…å­˜çš„è¿ç»­æ€§è¿™ä¸€å‡è®¾ï¼Œè¿™ä¹Ÿä½¿å†…å­˜ç®¡ç†å˜å¾—æ›´åŠ å¤æ‚ï¼š

![image-20231121230237248](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231121230237248.png)

è¿è¡Œæ—¶ä½¿ç”¨äºŒç»´çš„ `runtime.heapArena` æ•°ç»„ç®¡ç†æ‰€æœ‰çš„å†…å­˜ï¼Œæ¯ä¸ªå•å…ƒéƒ½ä¼šç®¡ç† 64MB çš„å†…å­˜ç©ºé—´ï¼š

æºç ï¼š<https://github.com/golang/go/blob/go1.21.4/src/runtime/mheap.go#L235-L319>

```go
// A heapArena stores metadata for a heap arena. heapArenas are stored
// outside of the Go heap and accessed via the mheap_.arenas index.
type heapArena struct {
	_ sys.NotInHeap

	// bitmap stores the pointer/scalar bitmap for the words in
	// this arena. See mbitmap.go for a description.
	// This array uses 1 bit per word of heap, or 1.6% of the heap size (for 64-bit).
	bitmap [heapArenaBitmapWords]uintptr

	// If the ith bit of noMorePtrs is true, then there are no more
	// pointers for the object containing the word described by the
	// high bit of bitmap[i].
	// In that case, bitmap[i+1], ... must be zero until the start
	// of the next object.
	// We never operate on these entries using bit-parallel techniques,
	// so it is ok if they are small. Also, they can't be bigger than
	// uint16 because at that size a single noMorePtrs entry
	// represents 8K of memory, the minimum size of a span. Any larger
	// and we'd have to worry about concurrent updates.
	// This array uses 1 bit per word of bitmap, or .024% of the heap size (for 64-bit).
	noMorePtrs [heapArenaBitmapWords / 8]uint8

	// spans maps from virtual address page ID within this arena to *mspan.
	// For allocated spans, their pages map to the span itself.
	// For free spans, only the lowest and highest pages map to the span itself.
	// Internal pages map to an arbitrary span.
	// For pages that have never been allocated, spans entries are nil.
	//
	// Modifications are protected by mheap.lock. Reads can be
	// performed without locking, but ONLY from indexes that are
	// known to contain in-use or stack spans. This means there
	// must not be a safe-point between establishing that an
	// address is live and looking it up in the spans array.
	spans [pagesPerArena]*mspan

	// pageInUse is a bitmap that indicates which spans are in
	// state mSpanInUse. This bitmap is indexed by page number,
	// but only the bit corresponding to the first page in each
	// span is used.
	//
	// Reads and writes are atomic.
	pageInUse [pagesPerArena / 8]uint8

	// pageMarks is a bitmap that indicates which spans have any
	// marked objects on them. Like pageInUse, only the bit
	// corresponding to the first page in each span is used.
	//
	// Writes are done atomically during marking. Reads are
	// non-atomic and lock-free since they only occur during
	// sweeping (and hence never race with writes).
	//
	// This is used to quickly find whole spans that can be freed.
	//
	// TODO(austin): It would be nice if this was uint64 for
	// faster scanning, but we don't have 64-bit atomic bit
	// operations.
	pageMarks [pagesPerArena / 8]uint8

	// pageSpecials is a bitmap that indicates which spans have
	// specials (finalizers or other). Like pageInUse, only the bit
	// corresponding to the first page in each span is used.
	//
	// Writes are done atomically whenever a special is added to
	// a span and whenever the last special is removed from a span.
	// Reads are done atomically to find spans containing specials
	// during marking.
	pageSpecials [pagesPerArena / 8]uint8

	// checkmarks stores the debug.gccheckmark state. It is only
	// used if debug.gccheckmark > 0.
	checkmarks *checkmarksMap

	// zeroedBase marks the first byte of the first page in this
	// arena which hasn't been used yet and is therefore already
	// zero. zeroedBase is relative to the arena base.
	// Increases monotonically until it hits heapArenaBytes.
	//
	// This field is sufficient to determine if an allocation
	// needs to be zeroed because the page allocator follows an
	// address-ordered first-fit policy.
	//
	// Read atomically and written with an atomic CAS.
	zeroedBase uintptr
}
```

è¯¥ç»“æ„ä½“ä¸­çš„ `bitmap` å’Œ `spans` ä¸çº¿æ€§å†…å­˜ä¸­çš„ `bitmap` å’Œ `spans` åŒºåŸŸä¸€ä¸€å¯¹åº”ï¼Œ`zeroedBase` å­—æ®µæŒ‡å‘äº†è¯¥ç»“æ„ä½“ç®¡ç†çš„å†…å­˜çš„åŸºåœ°å€ã€‚å°†åŸæœ‰çš„è¿ç»­å¤§å†…å­˜åˆ‡åˆ†æˆç¨€ç–çš„å°å†…å­˜ï¼Œè€Œç”¨äºç®¡ç†è¿™äº›å†…å­˜çš„å…ƒä¿¡æ¯ä¹Ÿè¢«åˆ‡æˆäº†å°å—

ä¸åŒå¹³å°å’Œæ¶æ„çš„äºŒç»´æ•°ç»„å¤§å°å¯èƒ½å®Œå…¨ä¸åŒï¼Œå¦‚æœ Go è¯­è¨€æœåŠ¡åœ¨ Linux çš„ x86-64 æ¶æ„ä¸Šè¿è¡Œï¼ŒäºŒç»´æ•°ç»„çš„ä¸€ç»´å¤§å°ä¼šæ˜¯ 1ï¼Œè€ŒäºŒç»´å¤§å°æ˜¯ 4,194,304ï¼Œå› ä¸ºæ¯ä¸€ä¸ªæŒ‡é’ˆå ç”¨ 8 å­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œæ‰€ä»¥å…ƒä¿¡æ¯çš„æ€»å¤§å°ä¸º 32MBã€‚ç”±äºæ¯ä¸ª `runtime.heapArena` éƒ½ä¼šç®¡ç† 64MB çš„å†…å­˜ï¼Œæ•´ä¸ªå †åŒºæœ€å¤šå¯ä»¥ç®¡ç† 256TB çš„å†…å­˜ï¼Œè¿™æ¯”ä¹‹å‰çš„ 512GB å¤šå¥½å‡ ä¸ªæ•°é‡çº§

ç”±äºå†…å­˜çš„ç®¡ç†å˜å¾—æ›´åŠ å¤æ‚ï¼Œä¸Šè¿°æ”¹åŠ¨å¯¹åƒåœ¾å›æ”¶ç¨æœ‰å½±å“ï¼Œå¤§çº¦ä¼šå¢åŠ  1% çš„åƒåœ¾å›æ”¶å¼€é”€ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†è§£å†³å·²æœ‰é—®é¢˜å¿…é¡»ä»˜å‡ºçš„æˆæœ¬

## åœ°å€ç©ºé—´

å› ä¸ºæ‰€æœ‰çš„å†…å­˜æœ€ç»ˆéƒ½æ˜¯è¦ä»æ“ä½œç³»ç»Ÿä¸­ç”³è¯·çš„ï¼Œæ‰€ä»¥ Go è¯­è¨€çš„è¿è¡Œæ—¶æ„å»ºäº†æ“ä½œç³»ç»Ÿçš„å†…å­˜ç®¡ç†æŠ½è±¡å±‚ï¼Œè¯¥æŠ½è±¡å±‚å°†è¿è¡Œæ—¶ç®¡ç†çš„åœ°å€ç©ºé—´åˆ†æˆä»¥ä¸‹å››ç§çŠ¶æ€ï¼š

|    çŠ¶æ€    |                             è§£é‡Š                             |
| :--------: | :----------------------------------------------------------: |
|   `None`   |         å†…å­˜æ²¡æœ‰è¢«ä¿ç•™æˆ–è€…æ˜ å°„ï¼Œæ˜¯åœ°å€ç©ºé—´çš„é»˜è®¤çŠ¶æ€         |
| `Reserved` |        è¿è¡Œæ—¶æŒæœ‰è¯¥åœ°å€ç©ºé—´ï¼Œä½†æ˜¯è®¿é—®è¯¥å†…å­˜ä¼šå¯¼è‡´é”™è¯¯        |
| `Prepared` | å†…å­˜è¢«ä¿ç•™ï¼Œä¸€èˆ¬æ²¡æœ‰å¯¹åº”çš„ç‰©ç†å†…å­˜è®¿é—®è¯¥ç‰‡å†…å­˜çš„è¡Œä¸ºæ˜¯æœªå®šä¹‰çš„å¯ä»¥å¿«é€Ÿè½¬æ¢åˆ° `Ready` çŠ¶æ€ |
|  `Ready`   |                        å¯ä»¥è¢«å®‰å…¨è®¿é—®                        |

æ¯ä¸ªä¸åŒçš„æ“ä½œç³»ç»Ÿéƒ½ä¼šåŒ…å«ä¸€ç»„ç”¨äºç®¡ç†å†…å­˜çš„ç‰¹å®šæ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•å¯ä»¥è®©å†…å­˜åœ°å€ç©ºé—´åœ¨ä¸åŒçš„çŠ¶æ€ä¹‹é—´è½¬æ¢ï¼Œä¸åŒçŠ¶æ€ä¹‹é—´çš„è½¬æ¢è¿‡ç¨‹ï¼š

![image-20231122170847863](.assets/å†…å­˜åˆ†é…å™¨åŸç†/image-20231122170847863.png)

è¿è¡Œæ—¶ä¸­åŒ…å«å¤šä¸ªæ“ä½œç³»ç»Ÿå®ç°çš„çŠ¶æ€è½¬æ¢æ–¹æ³•ï¼Œæ‰€æœ‰çš„å®ç°éƒ½åŒ…å«åœ¨ä»¥ `mem_` å¼€å¤´çš„æ–‡ä»¶ä¸­

è¿è¡Œæ—¶ä½¿ç”¨ Linux æä¾›çš„ `mmap`ã€`munmap` å’Œ `madvise` ç­‰ç³»ç»Ÿè°ƒç”¨å®ç°äº†æ“ä½œç³»ç»Ÿçš„å†…å­˜ç®¡ç†æŠ½è±¡å±‚ï¼ŒæŠ¹å¹³äº†ä¸åŒæ“ä½œç³»ç»Ÿçš„å·®å¼‚ï¼Œä¸ºè¿è¡Œæ—¶æä¾›äº†æ›´åŠ æ–¹ä¾¿çš„æ¥å£ï¼Œé™¤äº† Linux ä¹‹å¤–ï¼Œè¿è¡Œæ—¶è¿˜å®ç°äº† BSDã€Darwinã€Plan9 ä»¥åŠ Windows ç­‰å¹³å°ä¸ŠæŠ½è±¡å±‚

- `runtime.sysAlloc`

ä»æ“ä½œç³»ç»Ÿä¸­è·å–ä¸€å¤§å—å¯ç”¨çš„å†…å­˜ç©ºé—´ï¼Œå¯èƒ½ä¸ºå‡ ç™¾ KB æˆ–è€…å‡  MB

```go
// sysAlloc transitions an OS-chosen region of memory from None to Ready.
// More specifically, it obtains a large chunk of zeroed memory from the
// operating system, typically on the order of a hundred kilobytes
// or a megabyte. This memory is always immediately available for use.
//
// sysStat must be non-nil.
//
// Don't split the stack as this function may be invoked without a valid G,
// which prevents us from allocating more stack.
//
//go:nosplit
func sysAlloc(n uintptr, sysStat *sysMemStat) unsafe.Pointer {
	sysStat.add(int64(n))
	gcController.mappedReady.Add(int64(n))
	return sysAllocOS(n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L38-L53>  

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L17-L35>

- `runtime.sysFree`

åœ¨ç¨‹åºå‘ç”Ÿå†…å­˜ä¸è¶³ï¼ˆOut-of Memoryï¼ŒOOMï¼‰æ—¶è°ƒç”¨å¹¶æ— æ¡ä»¶åœ°è¿”å›å†…å­˜

```go
// sysFree transitions a memory region from any state to None. Therefore, it
// returns memory unconditionally. It is used if an out-of-memory error has been
// detected midway through an allocation or to carve out an aligned section of
// the address space. It is okay if sysFree is a no-op only if sysReserve always
// returns a memory region aligned to the heap allocator's alignment
// restrictions.
//
// sysStat must be non-nil.
//
// Don't split the stack as this function may be invoked without a valid G,
// which prevents us from allocating more stack.
//
//go:nosplit
func sysFree(v unsafe.Pointer, n uintptr, sysStat *sysMemStat) {
	sysStat.add(-int64(n))
	gcController.mappedReady.Add(-int64(n))
	sysFreeOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L100-L117>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L144-L150>

- `runtime.sysReserve`

ä¿ç•™æ“ä½œç³»ç»Ÿä¸­çš„ä¸€ç‰‡å†…å­˜åŒºåŸŸï¼Œè®¿é—®è¿™ç‰‡å†…å­˜ä¼šè§¦å‘å¼‚å¸¸

```go
// sysReserve transitions a memory region from None to Reserved. It reserves
// address space in such a way that it would cause a fatal fault upon access
// (either via permissions or not committing the memory). Such a reservation is
// thus never backed by physical memory.
//
// If the pointer passed to it is non-nil, the caller wants the
// reservation there, but sysReserve can still choose another
// location if that one is unavailable.
//
// NOTE: sysReserve returns OS-aligned memory, but the heap allocator
// may use larger alignment, so the caller must be careful to realign the
// memory obtained by sysReserve.
func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {
	return sysReserveOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L133-L147>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L156-L162>

- `runtime.sysMap`

ä¿è¯å†…å­˜åŒºåŸŸå¯ä»¥å¿«é€Ÿè½¬æ¢è‡³å°±ç»ªçŠ¶æ€

```go
// sysMap transitions a memory region from Reserved to Prepared. It ensures the
// memory region can be efficiently transitioned to Ready.
//
// sysStat must be non-nil.
func sysMap(v unsafe.Pointer, n uintptr, sysStat *sysMemStat) {
	sysStat.add(int64(n))
	sysMapOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L149-L156>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L164-L173>

- `runtime.sysUsed`

é€šçŸ¥æ“ä½œç³»ç»Ÿåº”ç”¨ç¨‹åºéœ€è¦ä½¿ç”¨è¯¥å†…å­˜åŒºåŸŸï¼Œä¿è¯å†…å­˜åŒºåŸŸå¯ä»¥å®‰å…¨è®¿é—®

```go
// sysUsed transitions a memory region from Prepared to Ready. It notifies the
// operating system that the memory region is needed and ensures that the region
// may be safely accessed. This is typically a no-op on systems that don't have
// an explicit commit step and hard over-commit limits, but is critical on
// Windows, for example.
//
// This operation is idempotent for memory already in the Prepared state, so
// it is safe to refer, with v and n, to a range of memory that includes both
// Prepared and Ready memory. However, the caller must provide the exact amount
// of Prepared memory for accounting purposes.
func sysUsed(v unsafe.Pointer, n, prepared uintptr) {
	gcController.mappedReady.Add(int64(prepared))
	sysUsedOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L65-L78>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L84-L95>

- `runtime.sysUnused`

é€šçŸ¥æ“ä½œç³»ç»Ÿè™šæ‹Ÿå†…å­˜å¯¹åº”çš„ç‰©ç†å†…å­˜å·²ç»ä¸å†éœ€è¦ï¼Œå¯ä»¥é‡ç”¨ç‰©ç†å†…å­˜

```go
// sysUnused transitions a memory region from Ready to Prepared. It notifies the
// operating system that the physical pages backing this memory region are no
// longer needed and can be reused for other purposes. The contents of a
// sysUnused memory region are considered forfeit and the region must not be
// accessed again until sysUsed is called.
func sysUnused(v unsafe.Pointer, n uintptr) {
	gcController.mappedReady.Add(-int64(n))
	sysUnusedOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L55-L63>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L41-L82>

- `runtime.sysFault`

å°†å†…å­˜åŒºåŸŸè½¬æ¢æˆä¿ç•™çŠ¶æ€ï¼Œä¸»è¦ç”¨äºè¿è¡Œæ—¶çš„è°ƒè¯•

```go
// sysFault transitions a memory region from Ready to Reserved. It
// marks a region such that it will always fault if accessed. Used only for
// debugging the runtime.
//
// TODO(mknyszek): Currently it's true that all uses of sysFault transition
// memory from Ready to Reserved, but this may not be true in the future
// since on every platform the operation is much more general than that.
// If a transition from Prepared is ever introduced, create a new function
// that elides the Ready state accounting.
func sysFault(v unsafe.Pointer, n uintptr) {
	gcController.mappedReady.Add(-int64(n))
	sysFaultOS(v, n)
}
```

æºç ï¼š

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem.go#L119-L131>

<https://github.com/golang/go/blob/go1.21.4/src/runtime/mem_linux.go#L152-L154>