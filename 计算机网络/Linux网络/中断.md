## 什么是中断

CPU 工作的模式有两种

- 中断，由各种设备发起
- 轮询，由 CPU 主动发起

中断又分为两种：

- 硬中断：是由硬件产生的，比如，像磁盘，网卡，键盘
- 软中断：是由当前正在运行的进程所产生的。

中断（IRQ），尤其是软中断（softirq）的重要使用场景之一是网络收发包， 但并非唯一场景。

中断，是一种由硬件产生的电信号直接发送到中断控制器上，然后由中断控制器向 CPU 发送信号，CPU 检测到该信号后，会中断当前的工作转而去处理中断。然后，处理器会通知内核已经产生中断，这样内核就会对这个中断进行适当的处理。

当网卡收到数据包时会产生中断请求通知到 CPU，CPU 会中断当前正在运行的任务，然后通知内核有新数据包，内核调用中断处理程序进行响应，把数据包从网卡缓存及时拷贝到内存，否则会因为缓存溢出被丢弃。剩下的处理和操作数据包的工作就会交给软中断。

## 多队列网卡

当网卡不断的接收数据包，就会产生很多中断

RSS（Receive Side Scaling）是网卡的硬件特性，实现了多队列。通过多队列网卡驱动加载，获取网卡型号，得到网卡的硬件  queue 的数量，并结合 CPU 核的数量，最终通过 Sum=Min（网卡 queue，CPU core）得出所要激活的网卡 queue  数量。

然后将各个 queue 中断分布到 CPU 多个核上，实现负载均衡，避免了单个核被占用到 100%  而其他核还处于空闲的情况。同一数据流会始终在同一 CPU 上，避免 TCP 的顺序性和 CPU  的并行性的冲突。基于流的负载均衡，解决了顺序协议和 CPU 并行的冲突以及 cache 热度问题。

多队列需要网卡硬件的支持。如果服务器的网卡支持 RSS，会在系统中看到网卡对应多个发送和接收队列：

```bash
# ls /sys/class/net/enp1s0f0/queues/

rx-0  rx-1  rx-10  rx-11  rx-12  rx-13  rx-14  rx-15  rx-16  rx-2  rx-3  rx-4  rx-5  rx-6  rx-7  rx-8  rx-9  tx-0  tx-1  tx-10  tx-11  tx-12  tx-13  tx-14  tx-15  tx-2  tx-3  tx-4  tx-5  tx-6  tx-7  tx-8  tx-9
```

## IRQ 绑定

IRQ (Interrupt Request) 绑定，即中断请求绑定

- `/proc/interrupts` 文件中可以看到各个 CPU 上的中断情况。

- `/proc/irq/[irq_num]/smp_affinity_list` 可以查看指定中断当前绑定的 CPU。

查看下指定网卡的中断

```bash
# cat /proc/interrupts | grep enp1s0f0 | cut -d: -f1 | while read i; do echo -ne irq":$i\t bind_cpu: "; cat /proc/irq/$i/smp_affinity_list; done | sort -n -t' ' -k3

irq:141	 bind_cpu: 0
irq:139	 bind_cpu: 1
irq:138	 bind_cpu: 2
irq:137	 bind_cpu: 3
irq:144	 bind_cpu: 4
irq:145	 bind_cpu: 5
irq:134	 bind_cpu: 6
irq:135	 bind_cpu: 7
irq:142	 bind_cpu: 8
irq:143	 bind_cpu: 9
irq:133	 bind_cpu: 11
irq:140	 bind_cpu: 12
irq:148	 bind_cpu: 13
irq:132	 bind_cpu: 14
irq:147	 bind_cpu: 14
irq:136	 bind_cpu: 15
irq:146	 bind_cpu: 15
```

再查看下具体的中断情况：

```bash
# cat /proc/interrupts | grep enp1s0f0 | tr -s ' ' '\t'|cut -f 1-18
	132:	122	0	0	0	0	1	0	0	0	0	7848	0	0	0	14836	0
	133:	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0	0
	134:	0	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0
	135:	0	0	0	1	0	0	0	0	1	0	0	0	0	0	0	0
	136:	0	0	0	0	1	0	0	0	0	1	0	0	0	0	0	0
	137:	0	0	0	0	0	1	0	0	0	0	1	0	0	0	0	0
	138:	0	0	0	0	0	0	1	0	0	0	0	1	0	0	0	0
	139:	0	0	0	0	0	0	0	1	0	0	0	0	1	0	0	0
	140:	0	0	0	0	0	0	0	0	1	0	0	0	0	1	0	0
	141:	0	0	0	0	0	0	0	0	0	1	0	0	0	0	1	0
	142:	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	1
	143:	1	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
	144:	0	1	0	0	0	0	0	0	0	0	0	0	1	0	0	0
	145:	0	0	1	0	0	0	0	0	0	0	0	0	0	1	0	0
	146:	0	0	0	1	0	0	0	0	0	0	0	0	0	0	1	0
	147:	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	1
	148:	41	0	0	0	0	1	0	0	0	0	0	0	0	38311	0	0
```

## softnet_stat

查看下 softnet_stat 的情况：

```bash
# cat /proc/net/softnet_stat
00000004 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000288 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
00000002 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000002
000005fd 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000003
000001df 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000004
000000eb 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000005
00001fee 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000006
000003a7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007
000001a1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000008
000000b5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000009
00000078 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000a
00000148 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000b
000002ba 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000c
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000d
0000004e 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000e
0000000c 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000f
```

网卡收到包后会先将其放置在 per cpu 变量 softnet_data 里， 然后触发软中断从 softnet_data 里取数据包；

其中： 每一行代表每个 CPU 核的状态统计，从 CPU0 依次往下； 每一列代表一个 CPU 核的各项统计，每列用空格隔开，数值用 16 进制表示。

1. 第一列 `sd->processed`，是处理的网络帧的数量。如果你使用了 ethernet bonding，那这个值会大于总的网络帧的数量，因为 ethernet bonding 驱动有时会触发网络数据被重新处理（re-processed）

2. 第二列，`sd->dropped`，表示因 softnet_data 的输入队列满而丢弃的数据包个数（input_pkt_queue），即是因为处理不过来而 drop 的网络帧数量，队列长度最大值可通过 `/proc/sys/net/core/netdev_max_backlog` 调整）；

3. 第三列，`sd->time_squeeze`，由于 budget 或 time limit 用完而退出`net_rx_action` 循环的次数；

4. 第 4~8 列固定为 0，没有意义；

5. 第九列，`sd->cpu_collision`，是为了发送包而获取锁的时候有冲突的次数；

6. 第十列，`sd->received_rps`，是这个 CPU 被其他 CPU 唤醒去收包的次数；

7. 第十一列，`flow_limit_count`，是达到 flow limit 的次数

## 中断均衡

在很多优化的场景都需要将 irq 和处理进程绑定到不同的 CPU 上以提供更好的实时响应

- `/proc/irq/[irq_num]/smp_affinity`

该文件存放的是 CPU 位掩码（十六进制）。修改该文件中的值可以改变 CPU 和某中断的亲和性。

- `/proc/irq/[irq_num]/smp_affinity_list`

该文件存放的是 CPU 列表（十进制）。注意，CPU 核心个数用表示编号从 0 开始，如 CPU0, CPU1 等。

手动的对网卡的各个队列进行 CPU 绑定，如下：

```bash
echo 0 > /proc/irq/132/smp_affinity_list
echo 0 > /proc/irq/133/smp_affinity_list
echo 1 > /proc/irq/134/smp_affinity_list
echo 1 > /proc/irq/135/smp_affinity_list
echo 2 > /proc/irq/136/smp_affinity_list
echo 2 > /proc/irq/137/smp_affinity_list
......
```

## irqbalance

irqbalance 是根据系统中断负载的情况，自动迁移中断保持中断的平衡，同时会考虑到省电因素等等。但是在实时系统中会导致中断自动漂移，对性能造成不稳定因素，在高性能的场合建议关闭。