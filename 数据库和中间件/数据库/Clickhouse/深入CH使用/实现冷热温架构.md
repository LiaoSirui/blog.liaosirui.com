## TTL 和冷热温架构

- 使用 TTL（生存时间）管理数据 <https://clickhouse.com/docs/guides/developer/ttl>

<https://clickhouse.com/docs/guides/developer/ttl#implementing-a-hotwarmcold-architecture>

<https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree#table_engine-mergetree-multiple-volumes_configure>

定义磁盘

```xml
<clickhouse>
    <storage_configuration>
        <disks>
            <default>
            </default>
           <hot_disk>
              <path>./hot/</path>
              <keep_free_space_bytes>10485760</keep_free_space_bytes>
           </hot_disk>
           <warm_disk>
              <path>./warm/</path>
              <keep_free_space_bytes>10485760</keep_free_space_bytes>
           </warm_disk>
           <cold_disk>
              <path>./cold/</path>
              <keep_free_space_bytes>10485760</keep_free_space_bytes>
           </cold_disk>
        </disks>
        <policies>
            <default>
                <volumes>
                    <default>
                        <disk>default</disk>
                    </default>
                    <hot_volume>
                        <disk>hot_disk</disk>
                    </hot_volume>
                    <warm_volume>
                        <disk>warm_disk</disk>
                    </warm_volume>
                    <cold_volume>
                        <disk>cold_disk</disk>
                    </cold_volume>
                </volumes>
            </default>
        </policies>
    </storage_configuration>
</clickhouse>
```

`move_factor` — 当可用空间量低于此系数时，数据会自动开始在下一个卷上移动（如果有）（默认为 0.1）。ClickHouse 按大小从大到小（降序）对现有部件进行排序，并选择总尺寸足以满足 `move_factor` 条件的部件。如果所有零件的总尺寸不足，则所有零件将被移动。

## 调试

查看不同数据的盘

```sql
SELECT name, path, free_space, total_space
FROM system.disks;

SELECT volume_name,
    disks
FROM system.storage_policies;
```

查看分区

```sql
SELECT
    name,
    disk_name
FROM system.parts
WHERE (table = 'snapshot') AND (active = 1);

SELECT
    disk_name,
    count(*)
FROM system.parts
WHERE (table = 'snapshot') AND (active = 1) GROUP BY disk_name;

```

查看 MovePart 事件

- <https://clickhouse.com/docs/zh/operations/system-tables/parts>
- <https://clickhouse.com/docs/zh/operations/system-tables/part_log>
- <https://clickhouse.com/docs/zh/operations/system-tables/moves>

```sql
-- 获取最近发生 MovePart 事件的 part
WITH recent_moves AS
(
    SELECT
      database,
      table,
      partition_id,
      partition,
      part_name,
      disk_name,
      max(event_time) AS last_move_event_time
    FROM system.part_log
    WHERE event_type = 'MovePart'
    GROUP BY database, table, partition_id, partition, part_name
)
SELECT
  p.database,
  p.table,
  p.partition_id,
  p.partition,
  p.name AS part_name,
  p.disk_name AS current_disk,
  rm.disk_name AS target_disk,
  rm.last_move_event_time
FROM system.parts AS p
JOIN recent_moves AS rm
  ON p.database = rm.database
    AND p.table = rm.table
    AND p.partition_id = rm.partition_id
    AND p.name = rm.part_name
WHERE
  p.active = 1
  AND rm.last_move_event_time > now() - INTERVAL 30 MINUTE

-- 简单查询
SELECT
    event_time,
    database,
    table,
    event_type,
    partition ,
    disk_name,
    partition_id,
    part_name, 
    duration_ms,
    error 
FROM system.part_log
WHERE 
event_type ='MovePart' 
ORDER BY event_time DESC LIMIT 10;
```

查看正在移动的分片

```sql
--
SELECT 
  p.database,
  p.table,
  p.partition_id,
  p.partition,
  p.name AS part_name,
  p.disk_name AS current_disk,
  m.target_disk_name AS target_disk
FROM system.moves AS m
JOIN system.parts AS p
  ON p.database = m.database
    AND p.table = m.table
    AND p.name = m.part_name;
    
-- 针对表中的特殊 part_name 进行处理为日期
SELECT 
  p.database,
  p.table,
  p.partition_id,
  p.partition,
  p.name AS part_name,
  p.disk_name AS current_disk,
  m.target_disk_name AS target_disk,
  toDate(replaceRegexpAll(splitByChar(',', p.partition)[1], '[\'()]', '')) AS partition_date,
  partition_date > now() - INTERVAL 120 DAY as less_120day,
  partition_date > now() - INTERVAL 240 DAY as less_240day,
  now() - INTERVAL 120 DAY as d120days_ago,
  now() - INTERVAL 240 DAY as d240days_ago
FROM system.moves AS m
JOIN system.parts AS p
  ON p.database = m.database
    AND p.table = m.table
    AND p.name = m.part_name;

--
SELECT
    *
FROM system.moves LIMIT 1;
```

可以在与 Date 和 DateTime 类型值的算术操作中使用 Interval 类型的值。例如，可以给当前时间加上 4 天：

```sql
SELECT now() AS current_date_time, current_date_time + INTERVAL 4 DAY, current_date_time + toIntervalDay(4)
```

```bash
# ENGINE = ReplacingMergeTree?
SETTINGS storage_policy = 'moving_from_ssd_to_hdd'
```

文档：<https://clickhouse.com/docs/operations/system-tables/metrics#diskspacereservedformerge>

DiskSpaceReservedForMerge

Disk space reserved for currently running background merges. It is slightly more than the total size of currently merging parts.

文档 MergeTree 表 <https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree#details>

该磁盘的可用空间大于部分大小（`unreserved_space - keep_free_space_bytes > current_part_size`）

数据是否迁至冷数据盘，取决于 system.parts 表中`move_ttl_info.min`和`move_ttl_info.max`的值大小。可以使用以下语句获取二者的值。

```sql
SELECT move_ttl_info.min,move_ttl_info.max FROM system.parts WHERE database = '<db_name>'AND table = '<tb_name>'AND disk_name = 'default'
```

如果查询结果中，当前时间小于任意一个值，则该部分数据不应被移动到冷存。也有可能是系统正在进行或准备将该数据移动至冷数据盘的操作，但操作尚未处理完毕。

Clickhouse TTL 条件更新异常

```sql
SELECT 
    rows,
    toTimeZone(delete_ttl_info_min, 'UTC'),
    toTimeZone(delete_ttl_info_max, 'UTC'),
    move_ttl_info.expression, move_ttl_info.min, move_ttl_info.max
FROM system.parts WHERE database = currentDatabase() AND table = 'snapshot' AND active AND NOT has(`move_ttl_info.expression`, 'trading_day + toIntervalDay(120)');
```

## 参考资料

- <https://help.aliyun.com/zh/clickhouse/user-guide/tiered-storage-of-hot-data-and-cold-data>
