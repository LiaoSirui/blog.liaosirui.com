# 自旋锁简介

自旋锁（spin lock）与互斥锁（mutex）类似，任时刻只有一个线程能够获得锁。当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

在获取锁的过程中，线程一直处于活跃状态。因此与 mutex 不同，spinlock 不会导致线程的状态切换 (用户态 -> 内核态)，一直处于用户态，即线程一直都是 active 的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

由于自旋时不释放 CPU，如果持有自旋锁的线程一直不释放自旋锁，那么等待该自旋锁的线程会一直浪费 CPU 时间。因此，自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。

## 实现

伪代码实现：

```c
// 循环检查锁状态，并尝试获取，直到成功
while (true):
  locked = get_lock()
  if locked == false:
    locked = true
    break

// 上锁后执行相关任务
do_something

// 执行完毕，释放锁
locked = false

```

在并发场景会遇到问题：两个线程可能会同时进入`if`语句，同时获取锁，导致锁不生效。

可以把查询锁（get_lock）和设置锁（locked=true）组合成一个原子操作，保证同一时间只有一个线程在执行。如下所示：

```c
// 这里 get_and_set(locked) 就是一个原子操作，执行成功后把 locked 设置成 true。
while (get_and_set(locked) == false):
  continue

do_something

locked = false

```

如何实现`get_and_set(locked)`这个原子操作？这里有两个常用的方法可以使用：`TAS（test and set）`和`CAS （compare and swap）`。

1. `TAS`：一个 TAS 指令包括两个子步骤，把给定的内存地址设置为 1，然后返回之前的旧值。
2. `CAS`：CAS 指令需要三个参数，一个内存位置 (V)、一个期望旧值 (A)、一个新值 (B)。过程如下：
   - 比较内存 V 的值是否与 A 相等？
   - 如果相等，则用新值 B 替换内存位置 V 的旧值
   - 如果不相等，不做任何操作。
   - 无论哪个情况，CAS 都会把内存 V 原来的值返回。

很多语言都提供了封装后的 TAS 和 CAS 调用方法。

1. 以 C++ 11 为例，`atomic` 标准库提供了相关方法：[std::atomic_flag::test_and_set](https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set) 和 [std::atomic::compare_exchange_strong](http://www.cplusplus.com/reference/atomic/atomic/compare_exchange_strong/)
2. GCC 编译器也内置了相关方法：`__atomic_test_and_set` 和 `__atomic_compare_exchange_n`.
3. Java 也提供了例如 `java.util.concurrent.atomic.AtomicReference.compareAndSet` 等方法。

使用这些方法替换伪代码中的 `get_and_set (locked)`，就能快速实现自旋锁。

## 参考实现

### MariaDB 10.4

代码路径：`/storage/innobase/include/ib0mutex.h`

```c
struct TTASMutex {

    ...

    /** Try and lock the mutex.
    @return true on success */
    bool try_lock() UNIV_NOTHROW
    {
        uint32_t oldval = MUTEX_STATE_UNLOCKED;
        return m_lock_word.compare_exchange_strong(
            oldval,
            MUTEX_STATE_LOCKED,
            std::memory_order_acquire,
            std::memory_order_relaxed);
    }

    /** Acquire the mutex.
    @param max_spins max number of spins
    @param max_delay max delay per spin */
    void enter(uint32_t max_spins, uint32_t max_delay,
            const char*, uint32_t) UNIV_NOTHROW
    {
        const uint32_t step = max_spins;
        uint32_t n_spins = 0;

        while (!try_lock()) {
            ut_delay(max_delay);
            if (++n_spins == max_spins) {
                os_thread_yield();
                max_spins+= step;
            }
        }

        m_policy.add(n_spins, 0);
    }

    ...
}

```

如上所示，在 `TTASMutex` 结构里，有个 `enter` 方法，里面实现了上锁 + 自旋的功能。其中上锁动作调用了 `try_lock` 方法，里面使用了 CAS 原子操作。

在我们之前写的简单伪代码中，while 循环内什么都没做（直接 continue），即每次自旋之间无停顿、无其他操作。而 mariaDB 这里却做了一些动作，在每次 while 循环中：

1. 执行 `ut_delay`。即每次上锁失败后，会等待一段时间，然后再去尝试上锁。
2. 判断自旋次数，当自旋次数达到某个阈值，不再自旋，直接线程挂起。

这样做可以防止某些自旋锁无限空转、浪费 CPU 资源的情况。

### PostgreSQL

代码路径：`src/include/storage/s_lock.h`

```c
/*
 * s_lock(lock) - platform-independent portion of waiting for a spinlock.
 */
int
s_lock(volatile slock_t *lock, const char *file, int line, const char *func)
{
    SpinDelayStatus delayStatus;

    init_spin_delay(&delayStatus, file, line, func);

    while (TAS_SPIN(lock))
    {
        perform_spin_delay(&delayStatus);
    }

    finish_spin_delay(&delayStatus);

    return delayStatus.delays;
}

```

可以看到，与 MariaDB 类似，while 的判断中不断获取锁，while 语句中加入 delay。`TAS_SPIN`的实现如下：

```c
static __inline__ int
tas(volatile slock_t *lock)
{
    return __sync_lock_test_and_set(lock, 1);
}

```

`__sync_lock_test_and_set`是 gcc 内置的老版本的 TAS 原子操作，推荐使用`__atomic_test_and_set`

### Linux kernel

Kernel 的 spin lock 很复杂，有多种实现，以 arm64 为例，在 4.16 版本之前，使用的是汇编实现。4.16 之后 [使用](https://github.com/torvalds/linux/commit/c11090474d70590170cf5fa6afe85864ab494b37#diff-b986d1b5abd625b1eb28906791cef2146c371d10e4e8e5b23bb9f4158c2f16f1) 了通用的 qspinlock，qspinlock 较复杂

## 参考文档

- <https://kunpengcompute.github.io/2020/12/07/zi-xuan-suo-de-yuan-li-yu-you-hua/>